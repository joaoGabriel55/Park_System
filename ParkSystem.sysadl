Model SysADLArchitecture;
package SysADL.types {
	value type Int {
	}
	value type Boolean {
	}
	value type String {
	}
	value type Void {
	}
	value type Real {
	}
	enum Comando {
		ABRIR, FECHAR
	, EMERGENCIA
	}
	enum Tipo {
		VERDE, AZUL, AMARELO
	}
	dimension Identificacao
	unit Codigo {
		dimension = Identificacao }
		value type CodigoIdentificacao {
			unit = Codigo
			dimension = Identificacao
		}
	}
	Requirement GerenciadorVagasFR ( 1 ) {
		text =
		"O sistema deve monitorar cada uma das vagas do estacionamento e sinalizar o status da vaga por meio de lâmpadas, diferenciando as vagas destinadas a idosos e deficientes físicos das demais" satisfied
		by ParkingSystemComponents.GerenciadorVagas;
		Requirement TipoVagaFR ( 1.1 ) {
			text =
			"O status da vaga deve ser representado pela cor da lâmpada associada a ela, a cor vermelha indica que a vaga está ocupada, a cor verde indica que a vaga está disponível, a cor amarela indica que a vaga está disponível e que é destinada a idosos, a cor azul indica que a vaga está disponível e que é destinada à deficientes físicos."
			satisfied by ParkingSystemComponents.TipoVagaLedCP;
			derive DetectarStatusVagaFR;
		}
		Requirement ContadorVagasDiponiveisFR ( 1.3 ) {
			text =
			"O sistema deve indicar em painéis a quantidade de vagas disponíveis em cada ala do estacionamento."
		satisfied by ParkingSystemComponents.ControladorQtdVagas;
		}
	}
	Requirement DetectarStatusVagaFR ( 1.2 ) {
		text =
		"O sistema deve detectar para cada vaga do estacionamento se existe ou não um veículo estacionado"
	satisfied by ParkingSystemComponents.DetectorPresencaVagaCP;
	}
	Requirement GerenciadorEntradaVeiculosFR ( 2 ) {
		text =
		"O sistema deve controlar a entrada de veículos por meio de uma cancela eletrônica. Um ticket com código de barras deve ser impresso para cada motorista antes do mesmo entrar no estacionament" satisfied
		by ParkingSystemComponents.GerenciadorEntradaSaidaVeiculo;
		Requirement ImprimirTicketFR ( 2.1 ) {
			text =
			"Antes de o motorista entrar no estacionamento um ticket com código de barras deve ser impresso e recolhido pelo motorista. Associado ao código de barras impresso no ticket o sistema deve armazenar a hora em que o ticket foi gerado."
		satisfied by ParkingSystemComponents.ImpressaoTicketCP;
		}
	}
	Requirement GerenciadorSaidaVeiculosFR ( 3 ) {
		text =
		"O sistema deve gerenciar a saída de veículos por meio de uma cancela eletrônica. Os veículos poderão deixar o estacionamento apenas após o pagamento da taxa de estacionamento." satisfied
		by ParkingSystemComponents.GerenciadorEntradaSaidaVeiculo;
		Requirement LerTicketFR ( 3.1 ) {
			text =
			"A partir da leitura do código de barras impresso no ticket o sistema deve recuperar todas as informações associadas ao ticket (horário de entrada no estacionamento, valor da taxa de estacionamento,  se a taxa foi ou não paga, se foi paga o horário de pagamento )."
		satisfied by ParkingSystemComponents.LeituraTicketCP;
		}
	}
	Requirement DetectorVeiculoFR ( 4 ) {
		text =
		"Ao se se aproximar com o veículo da cancela eletrônica a presença do veículo deve ser detectada de forma automática."
	satisfied by ParkingSystemComponents.DetectorEntradaVeiculoCP,
		ParkingSystemComponents.DetectorSaidaVeiculoCP;
	}
	Requirement AbrirCancelaEletronicaFR ( 5 ) {
		text =
		"A cancela eletrônica deve abrir automaticamente após o motorista recolher o ticket impresso na entrada e no momento em que o motorista apresentar o ticket devidamente paga na saída do estacionamento"
	satisfied by ParkingSystemComponents.EntradaCancelaCP,
		ParkingSystemComponents.SaidaCancelaCP;
	}
	Requirement GerenciadorPagamentoFR ( 6 ) {
		text =
		"O sistema deve permitir ao usuário realizar o pagamento da taxa de estacionamento. O pagamento deve ser calculado com base no tempo em que o veículo esteve no estacionamento." satisfied
		by ParkingSystemComponents.GerenciadorPagamentoCP;
		Requirement RealizarPagamentoFR ( 6.1 ) {
			text =
			"O sistema deve permitir ao usuário realizar o pagamento em caixas automáticos com cartão ou dinheiro."
		}
	}
	Requirement AbrirCancelaEmergencialFR ( 7 ) {
		text =
		"Em casos de emergência o operador do estacionamento poderá abrir a cancela de emergência."
	satisfied by ParkingSystemComponents.BotaoDeEmergenciaCP;
	}
	package ParkingSystemConnectors {
		import ParkingSystemPorts;
		import SysADL.types;
		connector def DetectarPresencaCN {
			participants:
			~origem : PresencaVeiculoIPT [ 1, -1 ];
			~destino : PresencaVeiculoOPT;
			flows:
			Boolean from origem to destino
		}
		connector def CtrlComandoCN {
			participants:
			~destino : CommandOPT;
			~origem : CommandIPT [ 1, -1 ];
			flows:
			Comando from origem to destino
		}
		connector def QuantidadeVagasCN {
			participants:
			~destino : VagasOPT;
			~origem : VagasIPT;
			flows:
			Int from origem to destino
		}
		connector def StatusPagamentoCN {
			participants:
			~origem : StatusPagamentoIPT;
			~destino : StatusPagamentoOPT;
			flows:
			Boolean from origem to destino
		}
		connector def CtrlTipoCorVagaCN {
			participants:
			~origem : TipoCorVagaIPT;
			~destino : TipoCorVagaOPT;
			flows:
			Tipo from origem to destino
		}
		connector def CodigoTicketCN {
			participants:
			~origem : CodigoTicketIPT;
			~destino : CodigoTicketOPT;
			flows:
			String from origem to destino
		}
		connector def GerarTicketCN {
			participants:
			~origem : GerarTicketIPT;
			~destino : GerarTicketOPT;
			flows:
			Boolean from origem to destino
		}
	}
	package ParkingSystemComponents {
		import ParkingSystemPorts;
		import ParkingSystemConnectors;
		import SysADL.types;
		component def GerenciadorVagas {
			ports:
			
			
			outVagas : VagasOPT;
			
			configuration {
				components:
				ControladorVagaLocal : ControladorVagaLocal {
					using
					ports:
					outPresenca : PresencaVeiculoOPT;
					inModificaCorTipoVaga : TipoCorVagaIPT;
				}
				ControladorQtdVagas : ControladorQtdVagas {
					using
					ports:
					inQtdVagas : VagasIPT;
				}
				GerenciadorVagasCP : GerenciadorVagasCP {
					using
					ports:
					inPresenca : PresencaVeiculoIPT;
					outModificaCorTipoVaga : TipoCorVagaOPT;
					outVagas : VagasOPT;
					outQtdVagas : VagasOPT;
				}
				connectors:
				presenca : DetectarPresencaCN bindings outPresenca = inPresenca;
				modificaCorTipoVaga : CtrlTipoCorVagaCN bindings outModificaCorTipoVaga =
				inModificaCorTipoVaga;
				vagasQtd : QuantidadeVagasCN bindings outQtdVagas = inQtdVagas;
				delegations:
				outVagas to outVagas
			}
		}
		boundary component def TipoVagaLedCP {
			ports:
			inTipoCorVaga : TipoCorVagaIPT;
		}
		boundary component def DetectorPresencaVagaCP {
			ports:
			outSensor : PresencaVeiculoOPT;
		}
		boundary component def DisplayVagasDisponiveisCP {
			ports:
			inQtdVagasDisplay : VagasIPT;
		}
		component def GerenciadorEntradaSaidaVeiculo {
			ports:
			inVagas : VagasIPT;
			configuration {
				components:
				
				GerenciadorEntradaSaidaCP : GerenciadorEntradaSaidaCP {
					using
					ports:
					inCodTicket : CodigoTicketIPT;
					outCodTicketSaida : CodigoTicketOPT;
					outVagas : VagasOPT;
				}
				ControleEntradaCancela : ControleEntradaCancela {
					using
					ports:
					inVagas : VagasIPT;
					outCodTicket : CodigoTicketOPT;
				}
				BotaoDeEmergenciaCP : BotaoDeEmergenciaCP {
					using
					ports:
					outSaidaEmergencia : CommandOPT;
				}
				ControleSaidaCancela : ControleSaidaCancela {
					using
					ports:
					inCodTicketSaida : CodigoTicketIPT;
					inEmergencia : CommandIPT;
				}
				connectors:
				
				codTicket : CodigoTicketCN bindings outCodTicket = inCodTicket;
				emergenciaCmd : CtrlComandoCN bindings outSaidaEmergencia = inEmergencia;
				codTicketSaida : CodigoTicketCN bindings outCodTicketSaida =
				inCodTicketSaida;
				delegations:
				inVagas to inVagas
			}
		}
		boundary component def ImpressaoTicketCP {
			ports:
			inGerarTicket : GerarTicketIPT;
			outCodTicket : CodigoTicketOPT;
		}
		component def LeituraTicketCP {
			ports:
			outLeituraTicket : CodigoTicketOPT;
		}
		component def BotaoDeEmergenciaCP {
			ports:
			outSaidaEmergencia : CommandOPT;
		}
		component def DetectorEntradaVeiculoCP {
			ports:
			outCtrlEntrada : CommandOPT;
		}
		component def ControleSaidaCancelaCP {
			ports:
			outCtrlCancela : CommandOPT;
			inLeituraTicket : CodigoTicketIPT;
			inSaida : CommandIPT;
			inStatusPag : StatusPagamentoIPT;
		}
		boundary component def GerenciadorPagamentoCP {
			ports:
			inCodTicketExit : CodigoTicketIPT;
			outStatusPag : StatusPagamentoOPT;
		}
		component def ParkingSystem {
			configuration {
			components:
				GerenciadorVagas : GerenciadorVagas {
					using
					ports:
					outVagas : VagasOPT;
				}
				GerenciadorEntradaSaidaVeiculo : GerenciadorEntradaSaidaVeiculo {
					using
					ports:
					inVagas : VagasIPT;
				}
				connectors:
				informaVagas : QuantidadeVagasCN bindings outVagas = inVagas;
			}
		}
		component def ControladorQtdVagasCP {
			ports:
			inQtdVagas : VagasIPT;
			outQtdVagasDisplay : VagasOPT;
		}
		component def ControladorVagaLocal {
			ports:
			outPresenca : PresencaVeiculoOPT;
			inModificaCorTipoVaga : TipoCorVagaIPT;
			configuration {
				components:
				TipoVagaLedCP : TipoVagaLedCP {
					using
					ports:
					inTipoCorVaga : TipoCorVagaIPT;
				}
				DetectorPresencaVagaCP : DetectorPresencaVagaCP {
					using
					ports:
					outSensor : PresencaVeiculoOPT;
				}
				ControladorVagaLocalCP : ControladorVagaLocalCP {
					using
					ports:
					inSensor : PresencaVeiculoIPT;
					outTipoCorVaga : TipoCorVagaOPT;
					outPresenca : PresencaVeiculoOPT;
					inModificaCorTipoVaga : TipoCorVagaIPT;
				}
				connectors:
				presencaToVaga : DetectarPresencaCN bindings inSensor = outSensor;
				trocarCorTipoVaga : CtrlTipoCorVagaCN bindings outTipoCorVaga =
				inTipoCorVaga;
				delegations:
				outPresenca to outPresenca inModificaCorTipoVaga to inModificaCorTipoVaga
			}
		}
		component def DetectorSaidaVeiculoCP {
			ports:
			outSaida : CommandOPT;
		}
		component def ControleEntradaCancelaCP {
			ports:
			inCtrlEntrada : CommandIPT;
			inVagas : VagasIPT;
			outGerarTicket : GerarTicketOPT;
			outCtrlCancela : CommandOPT;
		}
		boundary component def EntradaCancelaCP {
			ports:
			inCtrlCancela : CommandIPT;
		}
		boundary component def SaidaCancelaCP {
			ports:
			inCtrlCancela : CommandIPT;
		}
		component def ControladorVagaLocalCP {
			ports:
			inSensor : PresencaVeiculoIPT;
			outTipoCorVaga : TipoCorVagaOPT;
			outPresenca : PresencaVeiculoOPT;
			inModificaCorTipoVaga : TipoCorVagaIPT;
		}
		component def ControladorQtdVagas {
			ports:
			inQtdVagas : VagasIPT;
			configuration {
				components:
				ControladorQtdVagasCP : ControladorQtdVagasCP {
					using
					ports:
					inQtdVagas : VagasIPT;
					outQtdVagasDisplay : VagasOPT;
				}
				DisplayVagasDisponiveisCP : DisplayVagasDisponiveisCP {
					using
					ports:
					inQtdVagasDisplay : VagasIPT;
				}
				connectors:
				qtdVagasDisplay : QuantidadeVagasCN bindings outQtdVagasDisplay =
				inQtdVagasDisplay;
				delegations:
				inQtdVagas to inQtdVagas
			}
		}
		component def ControleEntradaCancela {
			ports:
			inVagas : VagasIPT;
			outCodTicket : CodigoTicketOPT;
			configuration {
				components:
				ImpressaoTicket : ImpressaoTicketCP {
					using
					ports:
					inGerarTicket : GerarTicketIPT;
					outCodTicket : CodigoTicketOPT;
				}
				ControleEntradaCancelaCP : ControleEntradaCancelaCP {
					using
					ports:
					inCtrlEntrada : CommandIPT;
					inVagas : VagasIPT;
					outGerarTicket : GerarTicketOPT;
					outCtrlCancela : CommandOPT;
				}
				EntradaCancelaCP : EntradaCancelaCP {
					using
					ports:
					inCtrlCancela : CommandIPT;
				}
				DetectorEntradaVeiculoCP : DetectorEntradaVeiculoCP {
					using
					ports:
					outCtrlEntrada : CommandOPT;
				}
				connectors:
				ctrlEntradaCancela : CtrlComandoCN bindings outCtrlCancela = inCtrlCancela;
				detectorEntrada : CtrlComandoCN bindings outCtrlEntrada = inCtrlEntrada;
				gerarTicket : GerarTicketCN bindings outGerarTicket = inGerarTicket;
				delegations:
				outCodTicket to outCodTicket inVagas to inVagas
			}
		}
		component def ControleSaidaCancela {
			ports:
			inCodTicketExit : CodigoTicketIPT;
			inEmergencia : CommandIPT;
			configuration {
				components:
				GerenciadorPagamentoCP : GerenciadorPagamentoCP {
					using
					ports:
					inCodTicketExit : CodigoTicketIPT;
					outStatusPag : StatusPagamentoOPT;
				}
				DetectorSaidaVeiculoCP : DetectorSaidaVeiculoCP {
					using
					ports:
					outSaida : CommandOPT;
				}
				LeituraTicketCP : LeituraTicketCP {
					using
					ports:
					outLeituraTicket : CodigoTicketOPT;
				}
				SaidaCancelaCP : SaidaCancelaCP {
					using
					ports:
					inCtrlCancela : CommandIPT;
				}
				ControleSaidaCancelaCP : ControleSaidaCancelaCP {
					using
					ports:
					outCtrlCancela : CommandOPT;
					inLeituraTicket : CodigoTicketIPT;
					inSaida : CommandIPT;
					inStatusPag : StatusPagamentoIPT;
				}
				connectors:
				ctrlSaidaCancela : CtrlComandoCN bindings outCtrlCancela = inCtrlCancela;
				statusPagamento : StatusPagamentoCN bindings outStatusPag = inStatusPag;
				saidaComando : CtrlComandoCN bindings outSaida = inSaida;
				codTicket : CodigoTicketCN bindings outLeituraTicket = inLeituraTicket;
				delegations:
				inCodTicketExit to inCodTicketExit
			inCtrlCancela to inEmergencia
			}
		}
		component def GerenciadorEntradaSaidaCP {
			ports:
			inCodTicket : CodigoTicketIPT;
			outCodTicketExit : CodigoTicketOPT;
			outVagas : VagasOPT;
		}
		component def GerenciadorVagasCP {
			ports:
			inPresenca : PresencaVeiculoIPT;
			outModificaCorTipoVaga : TipoCorVagaOPT;
			outVagas : VagasOPT;
			outQtdVagas : VagasOPT;
		}
	}
	package ParkingSystemPorts {
		import SysADL.types;
		port def CommandIPT {
			flow in Comando
		}
		port def CommandOPT {
			flow out Comando
		}
		port def VagasIPT {
			flow in Int
		}
		port def VagasOPT {
			flow out Int
		}
		port def CodigoTicketOPT {
			flow out CodigoIdentificacao
		}
		port def GerarTicketIPT {
			flow in Boolean
		}
		port def GerarTicketOPT {
			flow out Boolean
		}
		port def CodigoTicketIPT {
			flow in CodigoIdentificacao
		}
		port def StatusPagamentoIPT {
			flow in Boolean
		}
		port def StatusPagamentoOPT {
			flow out Boolean
		}
		port def PresencaVeiculoIPT {
			flow in Boolean
		}
		port def PresencaVeiculoOPT {
			flow out Boolean
		}
		port def TipoCorVagaIPT {
			flow in Tipo
		}
		port def TipoCorVagaOPT {
			flow out Tipo
		}
	}
	Requirement QualidadeNFR ( 8 ) {
		text = "O sistema deve satisfazer o requisito não funcional de Qualidade"
		Requirement ModificabilidadeNFR ( 8.1 ) {
			text = "Permitir um baixo custo para modificações" derive
			ModificabilidadeDeSensoresNFR;
		}
	}
	Requirement ModificabilidadeDeSensoresNFR ( 8.2 ) {
		text =
		"Permitir que novas vagas e respectivos sensores sejam adicionados ao sistema"
	}